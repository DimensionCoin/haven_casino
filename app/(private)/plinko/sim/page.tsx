"use client";

import { useEffect, useRef, useState } from "react";
import { BallManager } from "@/lib/plinko/BallManager";
import { WIDTH } from "@/lib/plinko/constants";
import { pad } from "@/lib/plinko/padding";
import { PLINKO_MULTIPLIERS } from "@/lib/plinko/config"; // ðŸ‘ˆ multipliers

type OutputsMap = { [key: number]: number[] };

const INITIAL_OUTPUTS: OutputsMap = {
  0: [],
  1: [],
  2: [],
  3: [],
  4: [],
  5: [],
  6: [],
  7: [],
  8: [],
  9: [],
  10: [],
  11: [],
  12: [],
  13: [],
  14: [],
  15: [],
  16: [],
  17: [],
};

// ðŸ”¢ Tune this to change speed
const DROPS_PER_MINUTE = 1500; // ~1500 balls / minute
const DROP_INTERVAL_MS = Math.max(1, Math.floor(60000 / DROPS_PER_MINUTE));

// ðŸ’µ assume each ball is $1
const BET_PER_BALL = 1;

function Simulation() {
  const canvasRef = useRef<HTMLCanvasElement | null>(null);
  const [outputs, setOutputs] = useState<OutputsMap>(INITIAL_OUTPUTS);

  async function simulate(
    ballManager: BallManager,
    cancelledRef: { current: boolean }
  ) {
    while (!cancelledRef.current) {
      // Random small offset around center so we get a distribution
      const startX = pad(WIDTH / 2 + 20 * (Math.random() - 0.5));
      ballManager.addBall(startX);

      // â± faster dropping
      await new Promise((resolve) => setTimeout(resolve, DROP_INTERVAL_MS));
    }
  }

  useEffect(() => {
    if (!canvasRef.current) return;

    const cancelledRef = { current: false };

    const ballManager = new BallManager(
      canvasRef.current as HTMLCanvasElement,
      (index: number, startX?: number) => {
        setOutputs((prev) => {
          const existing = prev[index] ?? [];
          const nextArray =
            typeof startX === "number" ? [...existing, startX] : existing;

          return {
            ...prev,
            [index]: nextArray,
          };
        });
      }
    );

    // fire-and-forget async loop
    void simulate(ballManager, cancelledRef);

    return () => {
      cancelledRef.current = true;
      ballManager.stop();
    };
  }, []);

  // ---------- Stats helpers ----------

  const totalDrops = Object.values(outputs).reduce(
    (sum, arr) => sum + (arr?.length ?? 0),
    0
  );

  const sinkRows = Object.keys(outputs)
    .map((k) => Number(k))
    .sort((a, b) => a - b)
    .map((index) => {
      const count = outputs[index]?.length ?? 0;
      const pct = totalDrops ? ((count / totalDrops) * 100).toFixed(2) : "0.00";

      return { index, count, pct };
    });

  // ðŸ’° Session P&L if each ball = $1 bet
  const totalBet = totalDrops * BET_PER_BALL;

  const totalPayout = sinkRows.reduce((sum, row) => {
    const multiplier = PLINKO_MULTIPLIERS[row.index] ?? 0;
    const sinkPayout = row.count * multiplier * BET_PER_BALL;
    return sum + sinkPayout;
  }, 0);

  const sessionPnL = totalPayout - totalBet; // player P&L
  const rtpPct = totalBet > 0 ? (totalPayout / totalBet) * 100 : 0;

  // ---------- Download outcomes.ts ----------

  const handleDownloadOutcomes = () => {
    const fileContents = `// lib/plinko/outcomes.ts
// Auto-generated by Plinko Simulation UI. Let the sim run until youâ€™re happy
// with sample size, then copy this file into your repo.

export type PlinkoOutcomes = { [key: number]: number[] };

export const PLINKO_OUTCOMES: PlinkoOutcomes = ${JSON.stringify(
      outputs,
      null,
      2
    )} as const;
`;

    const blob = new Blob([fileContents], { type: "text/typescript" });
    const url = URL.createObjectURL(blob);

    const a = document.createElement("a");
    a.href = url;
    a.download = "outcomes.ts";
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  };

  return (
    <div className="flex flex-col lg:flex-row h-screen bg-black text-white">
      {/* LEFT PANEL: header + stats (scrollable) */}
      <div className="w-full lg:w-[40%] flex flex-col border-b lg:border-b-0 lg:border-r border-white/10">
        {/* Header (button never scrolls away) */}
        <div className="p-4 flex items-center justify-between gap-3">
          <div className="text-sm">
            <div className="font-semibold">Plinko Simulation</div>
            <div className="text-xs text-zinc-400">
              Let this run. When each sink has enough hits, download{" "}
              <code>outcomes.ts</code>.
            </div>
            <div className="text-[11px] text-zinc-500 mt-1">
              Total drops:{" "}
              <span className="font-mono text-zinc-200">{totalDrops}</span>
            </div>

            {/* ðŸ’µ Session P&L + RTP */}
            <div className="text-[11px] text-zinc-500">
              Total bet (@ $1/ball):{" "}
              <span className="font-mono text-zinc-200">
                ${totalBet.toFixed(2)}
              </span>
            </div>
            <div className="text-[11px] text-zinc-500">
              Total payout:{" "}
              <span className="font-mono text-emerald-300">
                ${totalPayout.toFixed(2)}
              </span>
            </div>
            <div className="text-[11px] mt-0.5">
              Session P&amp;L (player):{" "}
              <span
                className={`font-mono ${
                  sessionPnL >= 0 ? "text-emerald-300" : "text-red-400"
                }`}
              >
                {sessionPnL >= 0 ? "+" : ""}${sessionPnL.toFixed(2)}
              </span>
            </div>
            <div className="text-[11px] text-zinc-500">
              RTP:{" "}
              <span className="font-mono text-zinc-200">
                {rtpPct.toFixed(2)}%
              </span>
            </div>
          </div>

          <button
            onClick={handleDownloadOutcomes}
            className="px-3 py-1.5 text-xs rounded bg-emerald-500 hover:bg-emerald-600 text-black font-medium"
          >
            Download outcomes.ts
          </button>
        </div>

        {/* Stats table (scrolls independently) */}
        <div className="flex-1 p-4 overflow-y-auto">
          <table className="w-full text-left text-xs border border-white/10 rounded-md overflow-hidden">
            <thead className="bg-white/5">
              <tr>
                <th className="px-2 py-1">Sink</th>
                <th className="px-2 py-1">Multiplier</th>
                <th className="px-2 py-1">Hits</th>
                <th className="px-2 py-1">% of total</th>
              </tr>
            </thead>
            <tbody>
              {sinkRows.map(({ index, count, pct }) => (
                <tr key={index} className="border-t border-white/5">
                  <td className="px-2 py-1 font-mono text-zinc-200">{index}</td>
                  <td className="px-2 py-1 font-mono text-zinc-300">
                    {PLINKO_MULTIPLIERS[index] ?? 0}x
                  </td>
                  <td className="px-2 py-1 font-mono text-zinc-100">{count}</td>
                  <td className="px-2 py-1 font-mono text-zinc-300">{pct}%</td>
                </tr>
              ))}
            </tbody>
          </table>

          <p className="mt-3 text-[11px] text-zinc-500">
            Tip: tweak <code>DROPS_PER_MINUTE</code> if you want this faster or
            slower.
          </p>
        </div>
      </div>

      {/* RIGHT PANEL: canvas */}
      <div className="flex-1 flex items-center justify-center">
        <canvas ref={canvasRef} width={800} height={800} />
      </div>
    </div>
  );
}

export default Simulation;
